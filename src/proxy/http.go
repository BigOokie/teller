package proxy

import (
	"context"
	"crypto/tls"
	"fmt"
	"net/http"
	"strings"
	"sync"

	"encoding/json"

	"time"

	"github.com/NYTimes/gziphandler"
	"github.com/unrolled/secure"
	"golang.org/x/crypto/acme/autocert"

	"github.com/skycoin/skycoin/src/cipher"
	"github.com/skycoin/teller/src/daemon"
	"github.com/skycoin/teller/src/logger"
)

const (
	proxyRequestTimeout = time.Second * 5

	shutdownTimeout = time.Second * 5

	// https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/
	// The timeout configuration is necessary for public servers, or else
	// connections will be used up
	serverReadTimeout  = time.Second * 10
	serverWriteTimeout = time.Second * 60
	serverIdleTimeout  = time.Second * 120

	// Directory where cached SSL certs from Let's Encrypt are stored
	tlsAutoCertCache = "cert-cache"
)

var httpCodeNames = []string{
	http.StatusBadRequest:           "Bad Request",
	http.StatusMethodNotAllowed:     "Method Not Allowed",
	http.StatusNotAcceptable:        "Not Acceptable",
	http.StatusInternalServerError:  "Internal Server Error",
	http.StatusRequestTimeout:       "Request Timeout",
	http.StatusUnsupportedMediaType: "Unsupported Media Type",
	http.StatusForbidden:            "Forbidden",
}

type httpServ struct {
	logger.Logger
	Addr          string
	HttpsAddr     string
	StaticDir     string
	HtmlInterface bool
	StartAt       time.Time
	AutoTlsHost   string
	TlsCert       string
	TlsKey        string
	Gateway       *gateway

	httpListener  *http.Server
	httpsListener *http.Server
	quit          chan struct{}
}

func (hs *httpServ) Run() error {
	hs.Println("Http service start")
	if hs.Addr != "" {
		hs.Println("Http service address:", hs.Addr)
	}
	if hs.HttpsAddr != "" {
		hs.Println("Https service address:", hs.HttpsAddr)
	}
	defer hs.Debugln("Http service closed")

	hs.quit = make(chan struct{})

	mux := hs.setupMux()

	if hs.Addr != "" {
		hs.httpListener = setupHttpListener(hs.Addr, hs.HttpsAddr, []string{}, mux)
	}

	handleListenErr := func(f func() error) error {
		if err := f(); err != nil {
			select {
			case <-hs.quit:
				return nil
			default:
				return fmt.Errorf("http serve failed: %v", err)
			}
		}
		return nil
	}

	if hs.HttpsAddr != "" {
		hs.Println("Using TLS")

		allowedHosts := []string{}
		if hs.AutoTlsHost != "" {
			// When using -auto-tls-host,
			// which implies automatic Let's Encrypt SSL cert generation in production,
			// restrict allowed hosts to this host.
			allowedHosts = []string{hs.AutoTlsHost}
		}

		hs.httpsListener = setupHttpListener(hs.HttpsAddr, hs.HttpsAddr, allowedHosts, mux)

		tlsCert := hs.TlsCert
		tlsKey := hs.TlsKey

		if hs.AutoTlsHost != "" {
			hs.Println("Using Let's Encrypt autocert with host", hs.AutoTlsHost)
			// https://godoc.org/golang.org/x/crypto/acme/autocert
			// https://stackoverflow.com/a/40494806
			certManager := autocert.Manager{
				Prompt:     autocert.AcceptTOS,
				HostPolicy: autocert.HostWhitelist(hs.AutoTlsHost),
				Cache:      autocert.DirCache(tlsAutoCertCache),
			}

			hs.httpsListener.TLSConfig = &tls.Config{
				GetCertificate: certManager.GetCertificate,
			}

			// These will be autogenerated by the autocert middleware
			tlsCert = ""
			tlsKey = ""
		}

		errC := make(chan error)

		if hs.Addr == "" {
			return handleListenErr(func() error {
				return hs.httpsListener.ListenAndServeTLS(tlsCert, tlsKey)
			})
		} else {
			return handleListenErr(func() error {
				var wg sync.WaitGroup
				wg.Add(2)

				go func() {
					defer wg.Done()
					if err := hs.httpsListener.ListenAndServeTLS(tlsCert, tlsKey); err != nil {
						errC <- err
					}
				}()

				go func() {
					defer wg.Done()
					if err := hs.httpListener.ListenAndServe(); err != nil {
						errC <- err
					}
				}()

				done := make(chan struct{})

				go func() {
					wg.Wait()
					close(done)
				}()

				select {
				case err := <-errC:
					return err
				case <-hs.quit:
					return nil
				case <-done:
					return nil
				}
			})
		}

	} else {
		return handleListenErr(func() error {
			return hs.httpListener.ListenAndServe()
		})
	}

	return nil
}

func setupHttpListener(addr, httpsAddr string, allowedHosts []string, mux *http.ServeMux) *http.Server {
	sslRedirect := true
	if httpsAddr == "" {
		sslRedirect = false
	}

	secureMiddleware := secure.New(secure.Options{
		AllowedHosts: allowedHosts,
		SSLRedirect:  sslRedirect,
		SSLHost:      httpsAddr,

		// https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP
		// FIXME: Web frontend code has inline styles, CSP doesn't work yet
		// ContentSecurityPolicy: "default-src 'self'",

		// Set HSTS to one year, for this domain only, do not add to chrome preload list
		// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
		STSSeconds:           31536000, // 1 years
		STSIncludeSubdomains: false,
		STSPreload:           false,

		// Deny use in iframes
		// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
		FrameDeny: true,

		// Disable MIME sniffing in browsers
		// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
		ContentTypeNosniff: true,

		// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
		BrowserXssFilter: true,

		// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy
		// "same-origin" is invalid in chrome
		ReferrerPolicy: "no-referrer",
	})

	return &http.Server{
		Addr:         addr,
		Handler:      secureMiddleware.Handler(mux),
		ReadTimeout:  serverReadTimeout,
		WriteTimeout: serverWriteTimeout,
		IdleTimeout:  serverIdleTimeout,
	}
}

func (hs *httpServ) setupMux() *http.ServeMux {
	mux := http.NewServeMux()

	handleApi := func(path string, f http.HandlerFunc) {
		mux.Handle(path, gziphandler.GzipHandler(logHandler(hs.Logger, f)))
	}

	// API Methods
	handleApi("/api/bind", BindHandler(hs))
	handleApi("/api/status", StatusHandler(hs))

	// Static files
	if hs.HtmlInterface {
		mux.Handle("/", gziphandler.GzipHandler(http.FileServer(http.Dir(hs.StaticDir))))
	}

	return mux
}

func (hs *httpServ) Shutdown() {
	if hs.quit != nil {
		close(hs.quit)
	}

	shutdown := func(proto string, ln *http.Server) {
		if ln == nil {
			return
		}
		hs.Printf("Shutting down %s server, %s timeout\n", proto, shutdownTimeout)

		ctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
		defer cancel()

		if err := ln.Shutdown(ctx); err != nil {
			hs.Println(proto, "server shutdown error:", err)
		}
	}

	shutdown("HTTP", hs.httpListener)
	shutdown("HTTPS", hs.httpsListener)

	hs.quit = nil
}

// BindHandler binds skycoin address with a bitcoin address
// Method: POST
// Accept: application/json
// URI: /api/bind
// Args:
//    {"skyaddr": "..."}
func BindHandler(srv *httpServ) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		bindHandler(w, r, srv)
	}
}

type bindRequest struct {
	SkyAddr string `json:"skyaddr"`
}

func bindHandler(w http.ResponseWriter, r *http.Request, srv *httpServ) {
	w.Header().Set("Accept", "application/json")

	if !validMethod(w, r, srv.Gateway, []string{http.MethodPost}) {
		return
	}

	if r.Header.Get("Content-Type") != "application/json" {
		errorResponse(w, srv.Gateway, http.StatusUnsupportedMediaType)
		return
	}

	userBindReq := &bindRequest{}
	decoder := json.NewDecoder(r.Body)
	if err := decoder.Decode(&userBindReq); err != nil {
		errorResponse(w, srv.Gateway, http.StatusBadRequest, "Invalid json request body:", err)
		return
	}
	defer r.Body.Close()

	if userBindReq.SkyAddr == "" {
		errorResponse(w, srv.Gateway, http.StatusBadRequest, "Missing skyaddr")
		return
	}

	if !verifySkycoinAddress(w, srv.Gateway, userBindReq.SkyAddr) {
		return
	}

	if !readyToStart(w, srv.Gateway, srv.StartAt) {
		return
	}

	cxt, cancel := context.WithTimeout(r.Context(), proxyRequestTimeout)
	defer cancel()

	daemonBindReq := daemon.BindRequest{SkyAddress: userBindReq.SkyAddr}

	rsp, err := srv.Gateway.BindAddress(cxt, &daemonBindReq)
	if err != nil {
		handleGatewayResponseError(w, srv.Gateway, err)
		return
	}

	if err := jsonResponse(w, makeBindHTTPResponse(*rsp)); err != nil {
		srv.Gateway.Println(err)
	}
}

// StatusHandler returns the deposit status of specific skycoin address
// Method: GET
// URI: /api/status
// Args:
//     skyaddr
func StatusHandler(srv *httpServ) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		statusHandler(w, r, srv)
	}
}

func statusHandler(w http.ResponseWriter, r *http.Request, srv *httpServ) {
	if !validMethod(w, r, srv.Gateway, []string{http.MethodGet}) {
		return
	}

	skyAddr := r.URL.Query().Get("skyaddr")
	if skyAddr == "" {
		errorResponse(w, srv.Gateway, http.StatusBadRequest, "Missing skyaddr")
		return
	}

	if !verifySkycoinAddress(w, srv.Gateway, skyAddr) {
		return
	}

	if !readyToStart(w, srv.Gateway, srv.StartAt) {
		return
	}

	cxt, cancel := context.WithTimeout(r.Context(), proxyRequestTimeout)
	defer cancel()

	stReq := daemon.StatusRequest{SkyAddress: skyAddr}

	rsp, err := srv.Gateway.GetDepositStatuses(cxt, &stReq)
	if err != nil {
		handleGatewayResponseError(w, srv.Gateway, err)
		return
	}

	if err := jsonResponse(w, makeStatusHTTPResponse(*rsp)); err != nil {
		srv.Gateway.Println(err)
	}
}

func readyToStart(w http.ResponseWriter, gw gatewayer, startAt time.Time) bool {
	if time.Now().UTC().After(startAt.UTC()) {
		return true
	}

	msg := fmt.Sprintf("Event starts at %v", startAt)
	http.Error(w, msg, http.StatusForbidden)
	gw.Println(http.StatusForbidden, msg)

	return false
}

func validMethod(w http.ResponseWriter, r *http.Request, gw gatewayer, allowed []string) bool {
	for _, m := range allowed {
		if r.Method == m {
			return true
		}
	}

	w.Header().Set("Allow", strings.Join(allowed, ", "))

	status := http.StatusMethodNotAllowed
	errorResponse(w, gw, status, "Invalid request method:", r.Method)

	return false
}

func verifySkycoinAddress(w http.ResponseWriter, gw gatewayer, skyAddr string) bool {
	if _, err := cipher.DecodeBase58Address(skyAddr); err != nil {
		msg := fmt.Sprintf("Invalid skycoin address: %v", err)
		http.Error(w, msg, http.StatusBadRequest)
		gw.Println(http.StatusBadRequest, "Invalid skycoin address:", err, skyAddr)
		return false
	}
	return true
}

func handleGatewayResponseError(w http.ResponseWriter, gw gatewayer, err error) {
	if err == nil {
		return
	}

	if err == context.DeadlineExceeded {
		errorResponse(w, gw, http.StatusRequestTimeout)
		return
	}

	errorResponse(w, gw, http.StatusInternalServerError, err)
	return
}

func errorResponse(w http.ResponseWriter, gw gatewayer, code int, msgs ...interface{}) {
	http.Error(w, httpCodeNames[code], code)
	gw.Println(append([]interface{}{code, httpCodeNames[code]}, msgs...)...)
}

func jsonResponse(w http.ResponseWriter, data interface{}) error {
	w.Header().Set("Content-Type", "application/json")
	d, err := json.MarshalIndent(data, "", "    ")
	if err != nil {
		return err
	}

	if _, err := w.Write(d); err != nil {
		return err
	}
	return nil
}

func logHandler(log logger.Logger, hd http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		t := time.Now()
		hd(w, r)
		log.Printf("HTTP [%s] %dms %s \n", r.Method, time.Since(t)/time.Millisecond, r.URL.String())
	}
}
