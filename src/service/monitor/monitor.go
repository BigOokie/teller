package monitor

import (
	"context"
	"fmt"
	"time"

	"github.com/skycoin/teller/src/logger"
)

// EType event type
type EType uint8

const (
	// EBalanceChange represents the event of balance changing
	EBalanceChange = EType(iota)
)

const (
	// defaultEventBufferSize default event channel buffer size
	defaultEventBufferSize = 1024
	// defaultPushTimeout default timeout duration when event channel is full.
	defaultPushTimeout = 3 * time.Second
	// defaultCheckPeriod represents the default checking period
	defaultCheckPeriod = 5 * time.Second
)

// typeStr represents the type string
var typeStr = []string{
	EBalanceChange: "BalanceChangeEvent",
}

func (et EType) String() string {
	if int(et) < len(typeStr) {
		return typeStr[et]
	}
	return fmt.Sprintf("Invalid type:%d", et)
}

// Event represents an event that is generated by monitor
type Event struct {
	Type  EType
	Value interface{}
}

// EventHandler callback function for handling the event
type EventHandler func(e Event) error

// BalanceGetter interface provides function for checking address balance
type BalanceGetter interface {
	// GetRealtimeBalance checks the realtime address balance
	GetRealtimeBalance(addr string) (int64, error)
	// GetAllLocalBalances returns all local balances
	GetAllLocalBalances() map[string]int64
}

// config stores the monitor's configurations
type config struct {
	eventBuffSize int           // event channel buffer size
	pushTimeout   time.Duration // timeout duration for pushing Event
	checkPeriod   time.Duration // balance checking period
}

// AddressValue records address and it's balance
type AddressValue struct {
	Address string
	Value   int64
}

// Monitor for checking the balance changing of specific coin
type Monitor struct {
	BalanceGetter // balance getter
	config        // monitor configuration

	CoinName string           // coin name
	eventC   chan Event       // event channel
	ckTicker *time.Ticker     // check timer
	balances map[string]int64 // balance
	log      logger.Logger

	reqc        chan func() // channel to make writing and reading of member variable thread safe
	balanceRltC chan AddressValue
}

// New creates a Monitor instance
func New(name string, bg BalanceGetter, ops ...Option) *Monitor {
	m := &Monitor{
		CoinName:      name,
		BalanceGetter: bg,
		balances:      bg.GetAllLocalBalances(), // init the current address balances
		log:           logger.NewLogger("", false),
		reqc:          make(chan func()),
		balanceRltC:   make(chan AddressValue),
	}

	m.checkPeriod = defaultCheckPeriod
	m.eventBuffSize = defaultEventBufferSize
	m.pushTimeout = defaultPushTimeout

	for _, op := range ops {
		op(m)
	}

	m.ckTicker = time.NewTicker(m.config.checkPeriod)
	m.eventC = make(chan Event, m.config.eventBuffSize)
	return m
}

// Run starts the Monitor, it's none-blocking, returns event channel
func (mt *Monitor) Run(cxt context.Context) <-chan Event {
	go func() {
		mt.log.Debugln("Monitor start")
		for {
			select {
			case <-cxt.Done():
				mt.log.Println("Monitor exit")
				return
			case req := <-mt.reqc:
				mt.log.Debugln("Monitor req in")
				req()
				mt.log.Debugln("Monitor req out")

			case <-mt.ckTicker.C:
				for a := range mt.balances {
					go func(addr string) {
						rv, err := mt.GetRealtimeBalance(addr)
						if err != nil {
							mt.log.Debugf("Check balance of address:%s failed, err:%v", addr, err)
							return
						}
						mt.log.Debugln("Check balance of", addr, " value:", rv)
						mt.balanceRltC <- AddressValue{
							Address: addr,
							Value:   rv,
						}
					}(a)
				}

			case addrBal := <-mt.balanceRltC:
				localBal := mt.balances[addrBal.Address]
				if addrBal.Value == localBal {
					continue
				}

				// generate an event
				e := Event{
					Type: EBalanceChange,
					Value: AddressValue{
						Address: addrBal.Address,
						Value:   addrBal.Value - localBal,
					},
				}

				mt.log.Debugf("Generate balance change event, address:%s, value:%d", addrBal.Address, addrBal.Value-localBal)

				select {
				case mt.eventC <- e:
					// update the balance with realtime balance
					mt.balances[addrBal.Address] = addrBal.Value
				case <-time.After(mt.config.pushTimeout):
					mt.log.Debugln("Event channel is full")
					return
				}
			}
		}
	}()

	return mt.eventC
}

// AddAddress adds address balance monitor
func (mt *Monitor) AddAddress(address string) (err error) {
	mt.strand(func() {
		if _, ok := mt.balances[address]; ok {
			err = fmt.Errorf("Address %s already under monitoring", address)
			return
		}
		mt.balances[address] = 0
	})
	return
}

func (mt *Monitor) strand(f func()) {
	done := make(chan struct{})
	mt.reqc <- func() {
		defer close(done)
		f()
	}
	<-done
}
